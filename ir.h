#pragma once

#include <string>

enum EOperationType
{
    // statement
    OP_TYPE_cmp,
    OP_TYPE_jmp, OP_TYPE_je,
    OP_TYPE_jl, OP_TYPE_jle,
    OP_TYPE_jg, OP_TYPE_jge,
    OP_TYPE_jb, OP_TYPE_jbe,
    OP_TYPE_ja, OP_TYPE_jae,

    // expression
    OP_TYPE_mov,
    OP_TYPE_or, OP_TYPE_xor, OP_TYPE_and, OP_TYPE_not,  // bit-wise
    OP_TYPE_shl, OP_TYPE_shr,  // shift
    OP_TYPE_add, OP_TYPE_sub,
    OP_TYPE_mul, OP_TYPE_div, OP_TYPE_mod,
    OP_TYPE_inc, OP_TYPE_dec, OP_TYPE_neg,
    OP_TYPE_ref, OP_TYPE_deref,

    // routine
    OP_TYPE_param,
    OP_TYPE_call,
    OP_TYPE_ret,

    // FPU
    OP_TYPE_fld, OP_TYPE_fst,  // load/store
    OP_TYPE_fabs,
    OP_TYPE_fchs,  // change sign
    OP_TYPE_fadd, OP_TYPE_fsub,
    OP_TYPE_fmul, OP_TYPE_fdiv,
};

enum EOperandAddressMode
{
    OP_ADDR_invalid,
    OP_ADDR_reg,
    OP_ADDR_imm,
};

struct OperandAddress
{
    EOperandAddressMode mode;
    uint64_t value;
};

// TODO: Stringable
struct Operation
{
    EOperationType op;
    OperandAddress arg1, arg2, arg3;

    std::string toString() const;
};

class OperationUtil
{
   public:
    static std::string OperationTypeToString(EOperationType type);
};

// class OperationBlock
// {
//    public:
//     typedef size_t op_handle_t;

//    public:
//     //  add(arith_op, src_name, dst_name)
//     //  add(arith_op, src1_name, src2_name, dst_name)
//     //  add(jmp_op, dst_label)
//     //
//     //  add(jmp_op) -> op_handle_t
//     //  fix(op_handle_t, dst_label)
//     //
//     data_address_t getNextAddress();
//     op_handle_t addOperation(EOperationType t, data_address_t arg1 = 0,
//                              data_address_t arg2 = 0, data_address_t arg3 = 0);
//     void fixOperationArgument(op_handle_t op, data_address_t addr);
// };

// # block 0
// int a, b, c, s;
// a = 1, b = 2, c = 3;
// s = a + b + c;
// if (s == 4)
// { # block 1
//  b = (s++) + c;
//  { # block 2
//    int i, j, k;
//    i = b;
//    j = s;
//    k = i + j;
//    func(a, b, c);
//  }
// }
// return 0
//
// [ topological array model ]
// ? allocate space for temporaries (just reserve enough space)
//
//  data layout of blocks (block 0, block 1, ...)
//  | 0 | 1  | 2  | 3 | 4  | 5  | 6 |
//  | a | b  | c  | s | t0 | t1 |
//  |                 | t2 |
//  |                 | i  | j  | k |
//
//  ALLOC #7        # ALLOC 7
//  # block 0
//  MOV #1, 0       # MOV 1, a
//  MOV #2, 1       # MOV 2, b
//  MOV #3, 2       # MOV 3, c
//  ADD 0, 1, 4     # ADD a, b, t0
//  ADD 4, 2, 5     # ADD t0, c, t1
//  MOV 5, 3        # MOV t1, s
//  CMP 3, #4       # CMP s, 4
//  JNE #??         # JNE ??  (backpack)
//   # block 1
//   MOV 3, 4       # MOV s, t2
//   INC 3          # INC s
//   ADD 4, 2, 1    # ADD t2, c, b
//    # block 2
//    MOV 1, 4      # MOV b, i
//    MOV 3, 5      # MOV s, j
//    ADD 4, 5, 6   # ADD i, j, k
//    PARAM 0       # PARAM a
//    PARAM 1       # PARAM b
//    PARAM 2       # PARAM c
//    CALL "func"
//  RET 3           # RET s
//
//
//
//
// NOTE:
// variables (data with name, symbols in program): external data, argument data,
// local data
// temporaries (data without name, generated by compiler): temporary data
// def expression = { assignment, inc, dec }
//
// data location (in block):
//      topological array model
// jump (between blocks):
//      * enter block
//          allocate space
//      * exit block
//          free space
//
// HOW:
// pass 1: mark version of variables
//  * how about jump statement?
//    version is incorrect after jump.
// pass 2: emit IR (keep tracking of data array)
//  * how about jump statement?
//    first, we know expressions are done when jump,
//    so, no temporary when jump.
