C Grammar


================ Translation Unit ===============

translation-unit        := ( function-definition || declaration )+

================== Declaration ==================

function-definition     := ( specifiers )? declarator compound-stmt

declaration             := specifiers ( decl-init ( ',' decl-init )* )? ';'
                            # so int; is legal, though meaningless

# 如何判断是一个 function definition(F) 还是 declaration(D) ？
    parse specifiers
    if ';' -> D
    parse declarator
    if '{' -> F
    else -> D

================== Declarator ==================

specifiers              := ( storage-specifier | type-specifier | type-qualifier )+

decl-init               := declarator ( '=' init )?

declarator = (pointer)? (identifier || '(' declarator ')') ()


declarator              := ( pointer )?
                           ( identifier || '(' declarator ')' )
                           ( ('[' ( constant-expr )? ']')* || ('(' (parameter-list)? ')')? )
                            # FIRST => { '*' '(' identifier }


# 暂时忽略, 交给 declarator 处理，所以不支持 [] 这种 declarator
abstract-declarator     := ( pointer )?
                           ( '(' abstract-declarator ')' )?
                           ( ('[' ( constant-expr )? ']')* || ('(' ( parameter-list )? ')')? )

# C 里数组 如果作为函数返回类型，或者参数类型，统一转成指针

-------------------------------------------------

parameter-list          := parameter-declaration ( ',' parameter-declaration )* ( ',' '...' )?

parameter-declaration   := specifiers ( declarator || abstract-declarator )

---------------------------------------

init                    := assign-expr
                        || '{' init-list (',')? '}'

init-list               := init ( ',' init )*

---------------------------------------

type-name               := ( type-specifier | type-qualifier )+ abstract-declarator

# register VS volatile
# 'register' should be understood as a code quality check that the programmer is
# not inadvertently destroying optimisation opportunities by taking the address
# of the object.
# 'volatile' indicates that accesses to (reads from and writes to) the object are
# considered side effects and cannot be optimised away.

storage-specifier       := typedef || extern || static || auto || register

type-qualifier          := const || volatile

type-specifier          := void || char || short || int || long || float || double || signed || unsigned
                        || struct-or-union-specifier
                        || enum-specifier
                        || typedef-name


pointer                 := ( '*' [type-qualifier-list] )+

identifier              := [_a-zA-Z] [_a-zA-Z0-9]*

type-qualifier-list     := ( type-qualifier )+
identifier-list         := identifier ( ',' identifier )*

constant                := floating-constant
                        || integer-constant
                        || enumeration-constant
                        || character-constant

floating-constant       := ...

integer-constant        := dec-const integer-suffix
                        || oct-const integer-suffix
                        || hex-const integer-suffix
dec-const               := [1-9][0-9]*
oct-const               := 0[0-7]*
hex-const               := 0[xX][0-9a-fA-F]+
integer-suffix          := [uU][lL] || [lL][uU]


enumeration-constant    := identifier
character-constant      := ...

string-literal          := ( 'L' )? '"' ( s-char )* '"'
s-char                  := <all but " \ new-line >

assign-op               := = *= /= %= += -= <<= >>= &= ^= |=

unary-op                := & * + - ~ !

=============== struct/union/enum ===============

struct-or-union-specifier
                        := struct-or-union (identifier)? '{' ( struct-declaration )+ '}'
                           struct-or-union identifier

struct-or-union         := struct || union

struct-declaration      := ( type-specifier || type-qualifier )+ struct-declarator (',' struct-declarator)* ';'

struct-declarator       := declarator
                        || (declarator)? ':' constant-expr              # bit-field! why declarator is optional?

enum-specifier          := enum (identifier)? '{' enumerator ( ',' enumerator )* '}'
                        || enum identifier

enumerator              := enumeration-constant ( '=' constant-expression )?

=============== expr(completed) ===============

expr                    := comma-expr
comma-expr              := assign-expr ( ',' assign-expr )*

assign-expr             := ( unary-expr assign-op )* cond-expr

# a ? b1 : b2 ? c1 : c2;
# C 里 cond-expr 是 rvalue，C++ 里是 lvalue
cond-expr               := OR-expr ( '?' expr ':' cond-expr )?          # tricky here, why 'expr' and 'cond-expr' ??

OR-expr                 := AND-expr ( '||' logical-AND-expr )*

AND-expr                := bit-OR-expr ( '&&' bit-OR-expr )*

bit-OR-expr             := bit-XOR-expr ( '|' bit-XOR-expr )*

bit-XOR-expr            := bit-AND-expr ( '^' bit-AND-expr )*

bit-AND-expr            := eq-expr ( '&' eq-expr )*

eq-expr                 := rel-expr ( ('=='|'!=') rel-expr )*           # Note: a==b==c is legal, but irreasonable, eval from left to right

rel-expr                := shift-expr ( ('<'|'<='|'>'|'>=') shift-expr )*

shift-expr              := add-expr ( ('<<'|'>>') add-expr )*

add-expr                := mul-expr ( ('+'|'-') mul-expr )*

mul-expr                := cast-expr ( ('*'|'/'|'%') cast-expr )*

cast-expr               := ( '(' type-name ')' )* unary-expr

# prefix-expr
# ++i 在 C 里是 rvalue，C++ 里是 lvalue
unary-expr              := postfix-expr
                        || '++' unary-expr
                        || '--' unary-expr
                        || unary-op cast-expr
                        || 'sizeof' unary-expr
                        || 'sizeof' '(' type-name ')'

postfix-expr            := primary-expr
                        || postfix-expr '[' expr ']'
                        || postfix-expr '(' [argument-expr-list] ')'
                        || postfix-expr '.' identifier
                        || postfix-expr '->' identifier
                        || postfix-expr '++'
                        || postfix-expr '--'

primary-expr            := identifier || constant || string-literal || '(' expr ')'

argument-expr-list      := assign-expr ( ',' assign-expr )*

# constant folding
constant-expr           := cond-expr


=============== statement(completed) ===============

stmt                    := labeled-stmt
                        || compound-stmt
                        || expression-stmt
                        || selection-stmt
                        || iteration-stmt
                        || jump-stmt

                           # 注意这里，Label 是一个 identifier，不仅仅词法上符合，
                           # 语法行为也符合，比如有 function-wise scope。
                           # 而且，由于 Label: stmt 是一条语句，
                           # 所以 Label 无法在全局域出现，只能在某个函数体内。
labeled-stmt            := identifier ':' stmt
                        || 'case' constant-expr ':' stmt
                        || 'default' ':' stmt

compound-stmt           := '{' ( declaration )* ( stmt )* '}'

expression-stmt         := ( expr )? ';'

selection-stmt          := 'if' '(' expr ')' stmt
                        || 'if' '(' expr ')' stmt 'else' stmt           ＃ dangling 'else'
                        || 'switch' '(' expr ')' stmt

iteration-stmt          := 'while' '(' expr ')' stmt
                        || 'do' stmt 'while' '(' expr ')' ';'
                        || 'for' '(' ( expr )? ';' ( expr )? ';' ( expr )? ')' stmt

jump-stmt               := 'goto' identifier ';'
                        || 'continue' ';'
                        || 'break' ';'
                        || 'return' ( expr )? ';'


------------------------------------------------------------------------
C 的 specifiers 有效组合

TC_VOID: void
TC_CHAR: char
TC_UCHAR: unsigned char
TC_SCHAR: signed char
TC_SHORT: (signed) short (int)
TC_USHORT: unsigned short (int)
TC_INT: (signed) (int)
TC_UINT: unsigned (int)
TC_LONG: (signed) long (int)
TC_ULONG: unsigned long (int)
TC_FLOAT: float
TC_DOUBLE: double
TC_LDOUBLE: long double
TC_STRUCT: struct {}
TC_UNION: union {}
TC_ENUM: enum {}
TC_TYPENAME: typedef
