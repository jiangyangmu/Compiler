C Grammar

Q: 如何建树？

================ Translation Unit ===============

translation-unit        := ( function-definition || declaration )+

================== Declaration ==================

function-definition     := ( specifiers )? declarator compound-stmt

declaration             := specifiers (init-declarator-list)? ';'

init-declarator-list    := init-declarator
                        || init-declarator-list ',' init-declarator

init-declarator         := declarator ( '=' initializer )?

# 如何判断是一个 function definition(F) 还是 declaration(D) ？
    parse specifiers
    if ';' -> D
    parse declarator
    if '{' -> F
    else -> D

================== Declarator(completed) ==================
Q: 需要收集哪些 data? (type, object, env)
Q: 需要检测哪些 constrains?

declarator              := ( pointer )? direct-declarator
#Result: named object with type
#[type] PointerType

direct-declarator       := identifier
                        || '(' declarator ')'
                        || direct-declarator '[' (constant-expression)? ']'
                        || direct-declarator '(' parameter-type-list ')'
                        || direct-declarator '(' (identifier-list)? ')'
#FIRST: '*' '(' identifier
#[env] Symbol.name
#[type] ArrayType, FunctionType
#[FunctionType] createEnv

abstract-declarator     := pointer ( direct-abstract-declarator )?
                        || direct-abstract-declarator
#Result: just type
#[type] PointerType

direct-abstract-declarator
                        := '(' abstract-declarator ')'
                        || (direct-abstract-declarator)? '[' (constant-expr)? ']'
                        || (direct-abstract-declarator)? '(' (parameter-type-list)? ')'
                        # 解读：[2][3]存在的时候可以不要[1]，即不能匹配空
#[type] ArrayType, FunctionType
#[FunctionType] createEnv // invalid after ';'

================== Initialize(completed) ==================

initializer             := assign-expr
                        || '{' initializer-list (',')? '}'

initializer-list        := initializer ( ',' initializer )*

-------------------------------------------------
## tail

parameter-type-list     := parameter-list ( ',' '...' )?

parameter-list          := parameter-declaration
                        || parameter-list ',' parameter-declaration

parameter-declaration   := specifiers ( declarator || (abstract-declarator)? )

identifier-list         := identifier ( ',' identifier )*

-------------------------------------------------
## others

# register VS volatile
# 'register' should be understood as a code quality check that the programmer is
# not inadvertently destroying optimisation opportunities by taking the address
# of the object.
# 'volatile' indicates that accesses to (reads from and writes to) the object are
# considered side effects and cannot be optimised away.

specifiers              := ( storage-specifier | type-specifier | type-qualifier )+

storage-specifier       := typedef || extern || static || auto || register

type-qualifier          := const || volatile

type-specifier          := void || char || short || int || long || float || double || signed || unsigned
                        || struct-or-union-specifier
                        || enum-specifier
                        || typedef-name

type-name               := specifier-qualifier-list ( abstract-declarator )?

pointer                 := '*' (type-qualifier-list)? (pointer)?

identifier              := [_a-zA-Z] [_a-zA-Z0-9]*

type-qualifier-list     := ( type-qualifier )+

constant                := floating-constant
                        || integer-constant
                        || enumeration-constant
                        || character-constant

floating-constant       := ...

integer-constant        := dec-const integer-suffix
                        || oct-const integer-suffix
                        || hex-const integer-suffix
dec-const               := [1-9][0-9]*
oct-const               := 0[0-7]*
hex-const               := 0[xX][0-9a-fA-F]+
integer-suffix          := [uU][lL] || [lL][uU]


enumeration-constant    := identifier
character-constant      := ...

string-literal          := ( 'L' )? '"' ( s-char )* '"'
s-char                  := <all but " \ new-line >

assign-op               := = *= /= %= += -= <<= >>= &= ^= |=

unary-op                := & * + - ~ !

=============== struct/union/enum ===============

struct-or-union-specifier
                        := struct-or-union (identifier)? '{' ( struct-declaration )+ '}'
                           struct-or-union identifier

struct-or-union         := 'struct' || 'union'

struct-declaration      := ( type-specifier || type-qualifier )+ struct-declarator-list ';'

struct-declarator-list  := struct-declarator
                        || struct-declarator-list ',' struct-declarator
struct-declarator       := declarator
                        || (declarator)? ':' constant-expr              # bit-field! why declarator is optional?

enum-specifier          := 'enum' (identifier)? '{' enumerator-list '}'
                        || 'enum' identifier

enumerator-list         := enumerator
                        || enumerator-list ',' enumerator
enumerator              := enumeration-constant ( '=' constant-expression )?

=============== expr(completed) ===============

expr                    := comma-expr
comma-expr              := assign-expr ( ',' assign-expr )*

assign-expr             := ( unary-expr assign-op )* cond-expr

# a ? b1 : b2 ? c1 : c2;
# C 里 cond-expr 是 rvalue，C++ 里是 lvalue
cond-expr               := OR-expr ( '?' expr ':' cond-expr )?          # tricky here, why 'expr' and 'cond-expr' ??

OR-expr                 := AND-expr ( '||' logical-AND-expr )*

AND-expr                := bit-OR-expr ( '&&' bit-OR-expr )*

bit-OR-expr             := bit-XOR-expr ( '|' bit-XOR-expr )*

bit-XOR-expr            := bit-AND-expr ( '^' bit-AND-expr )*

bit-AND-expr            := eq-expr ( '&' eq-expr )*

eq-expr                 := rel-expr ( ('=='|'!=') rel-expr )*           # Note: a==b==c is legal, but irreasonable, eval from left to right

rel-expr                := shift-expr ( ('<'|'<='|'>'|'>=') shift-expr )*

shift-expr              := add-expr ( ('<<'|'>>') add-expr )*

add-expr                := mul-expr ( ('+'|'-') mul-expr )*

mul-expr                := cast-expr ( ('*'|'/'|'%') cast-expr )*

cast-expr               := ( '(' type-name ')' )* unary-expr

# prefix-expr
# ++i 在 C 里是 rvalue，C++ 里是 lvalue
unary-expr              := postfix-expr
                        || '++' unary-expr
                        || '--' unary-expr
                        || unary-op cast-expr
                        || 'sizeof' unary-expr
                        || 'sizeof' '(' type-name ')'

postfix-expr            := primary-expr
                        || postfix-expr '[' expr ']'
                        || postfix-expr '(' [argument-expr-list] ')'
                        || postfix-expr '.' identifier
                        || postfix-expr '->' identifier
                        || postfix-expr '++'
                        || postfix-expr '--'

primary-expr            := identifier || constant || string-literal || '(' expr ')'

argument-expr-list      := assign-expr ( ',' assign-expr )*

# constant folding
constant-expr           := cond-expr


=============== statement(completed) ===============

stmt                    := labeled-stmt
                        || compound-stmt
                        || expression-stmt
                        || selection-stmt
                        || iteration-stmt
                        || jump-stmt

                           # 注意这里，Label 是一个 identifier，不仅仅词法上符合，
                           # 语法行为也符合，比如有 function-wise scope。
                           # 而且，由于 Label: stmt 是一条语句，
                           # 所以 Label 无法在全局域出现，只能在某个函数体内。
labeled-stmt            := identifier ':' stmt
                        || 'case' constant-expr ':' stmt
                        || 'default' ':' stmt

compound-stmt           := '{' ( declaration )* ( stmt )* '}'

expression-stmt         := ( expr )? ';'

selection-stmt          := 'if' '(' expr ')' stmt
                        || 'if' '(' expr ')' stmt 'else' stmt           ＃ dangling 'else'
                        || 'switch' '(' expr ')' stmt

iteration-stmt          := 'while' '(' expr ')' stmt
                        || 'do' stmt 'while' '(' expr ')' ';'
                        || 'for' '(' ( expr )? ';' ( expr )? ';' ( expr )? ')' stmt

jump-stmt               := 'goto' identifier ';'
                        || 'continue' ';'
                        || 'break' ';'
                        || 'return' ( expr )? ';'


------------------------------------------------------------------------
C 的 specifiers 有效组合

TC_VOID: void
TC_CHAR: char
TC_UCHAR: unsigned char
TC_SCHAR: signed char
TC_SHORT: (signed) short (int)
TC_USHORT: unsigned short (int)
TC_INT: (signed) (int)
TC_UINT: unsigned (int)
TC_LONG: (signed) long (int)
TC_ULONG: unsigned long (int)
TC_FLOAT: float
TC_DOUBLE: double
TC_LDOUBLE: long double
TC_STRUCT: struct {}
TC_UNION: union {}
TC_ENUM: enum {}
TC_TYPENAME: typedef
