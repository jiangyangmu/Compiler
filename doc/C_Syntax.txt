C Grammar

> 难点1: 基本结构 (串联, 并联, 递归)
> 难点2: 分支选择 (歧义消除)
> 难点3: 无用结点消除 (expression)

================ Translation Unit ===============

translation-unit        := external-declaration
                        || translation-unit external-declaration

external-declaration    := function-definition
                        || declaration
# [0] [1] ?
# DO S = parse <declaration-specifiers>
# DO D = parse <declarator>
# IF next() == FIRST(compound-statement) | FIRST(declaration-list) -> [0]
# IF next() == '=' | ',' | ';' -> [1]

# extra work:
# external-declaration: passing S and D to sub-node
#   function-definition: use them as data member
#   declaration: assert S != null, pass them again to init-declarator-list

function-definition     := [declaration-specifiers] declarator [declaration-list] compound-statment

# before modification      declaration-specifiers [init-declarator-list] ';'
declaration             := declaration-specifiers [ declarator [ '=' initializer ] [ ',' init-declarator-list ] ] ';'

init-declarator-list    := init-declarator
                        || init-declarator-list ',' init-declarator

init-declarator         := declarator
                        || declarator '=' initializer

declaration-list        := declaration
                        || declaration-list declaration

================== Declarator ==================

declarator              := [pointer] direct-declarator

direct-declarator       := identifier
                        || '(' declarator ')'
                        || direct-declarator '[' [constant-expr] ']'
                        || direct-declarator '(' parameter-type-list ')'
                        || direct-declarator '(' [identifier-list] ')'
# [3] [4] ?
# IF next() == ')' | FIRST(identifer-list) -> [4]
# ELSE -> [3]

abstract-declarator     := pointer [direct-abstract-declarator]
                        || direct-abstract-declarator

direct-abstract-declarator
                        := '(' abstract-declarator ')'
                        || [direct-abstract-declarator] '[' [constant-expr] ']'
                        || [direct-abstract-declarator] '(' [parameter-type-list] ')'
# [0] [2] ?
# IF next() == ')' | FIRST(declaration-specifiers) -> [2]
# ELSE -> [0]

parameter-type-list     := parameter-list
                        || parameter-list ',' '...'

parameter-list          := parameter-declaration
                        || parameter-list ',' parameter-declaration

parameter-declaration   := declaration-specifiers declarator
                        || declaration-specifiers [abstract-declarator]
# [0] [1] ?
# DO parse declaration-specifiers
# LOOP
#   skip pointer
#   SWITCH next()
#       CASE identifer -> [0]
#       CASE FIRST(declaration-specifiers) -> [1]
#       CASE '(' -> IF next2() == ')' -> [1]
#       CASE '[' -> [1]
#       CASE FOLLOW(parameter-declaration) -> [1]
#   skip 1

identifier-list         := identifier
                        || identifier-list ',' identifier

type-name               := specifier-qualifier-list [abstract-declarator]

pointer                 := '*' [type-qualifier-list]
                        || '*' [type-qualifier-list] pointer

================== Specifiers ==================

declaration-specifiers  := storage-class-specifier [declaration-specifiers]
                        || type-specifier [declaration-specifiers]
                        || type-qualifier [declaration-specifiers]

storage-class-specifier := 'typedef' || 'extern' || 'static' || 'auto' || 'register'

type-qualifier          := 'const' || 'volatile'

type-specifier          := 'void' || 'char' || 'short' || 'int' || 'long' || 'float' || 'double' || 'signed' || 'unsigned'
                        || struct-or-union-specifier
                        || enum-specifier
                        || typedef-name

type-qualifier-list     := type-qualifier
                        || type-qualifier-list type-qualifier

specifier-qualifier-list
                        := type-specifier [specifier-qualifier-list]
                        || type-qualifier [specifier-qualifier-list]

struct-or-union-specifier
                        := struct-or-union [identifier] '{' struct-declaration-list '}'
                        || struct-or-union identifier

struct-or-union         := 'struct' || 'union'

struct-declaration-list := struct-declaration
                        || struct-declaration-list struct-declaration

struct-declaration      := specifier-qualifier-list struct-declarator-list ';'

struct-declarator-list  := struct-declarator
                        || struct-declarator-list ',' struct-declarator

struct-declarator       := declarator
                        || [declarator] ':' constant-exprression            # bit-field! why declarator is optional?

enum-specifier          := 'enum' [identifier] '{' enumerator-list '}'
                        || 'enum' identifier

enumerator-list         := enumerator
                        || enumerator-list ',' enumerator

enumerator              := enumeration-constant
                        || enumeration-constant '=' constant-expr

typedef-name            := identifier

================== Initialize ==================

initializer             := assign-expr
                        || '{' initializer-list [','] '}'

initializer-list        := initializer
                        || initializer-list ',' initializer

=================== Expression ===============

expr                    := assign-expr
                        || expr ',' assign-expr

assign-expr             := cond-expr
                        || unary-expr assign-op assign-expr
# [0] [1] ?
# DO E = parse cond-expr
# IF E is unary-expr AND next() is assign-op -> [1]
# ELSE -> [0]

# a ? b1 : b2 ? c1 : c2;
# C 里 cond-expr 是 rvalue，C++ 里是 lvalue
# tricky here, why 'expr' and 'cond-expr' ??
cond-expr               := OR-expr
                        || OR-expr '?' expr ':' cond-expr

OR-expr                 := AND-expr
                        || OR-expr '||' AND-expr

AND-expr                := bit-OR-expr
                        || AND-expr '&&' bit-OR-expr

bit-OR-expr             := bit-XOR-expr
                        || bit-OR-expr '|' bit-XOR-expr

bit-XOR-expr            := bit-AND-expr
                        || bit-XOR-expr '^' bit-AND-expr

bit-AND-expr            := eq-expr
                        || bit-And-expr '&' eq-expr

eq-expr                 := rel-expr
                        || eq-expr '==' rel-expr
                        || eq-expr '!=' rel-expr

rel-expr                := shift-expr
                        || rel-expr '<' shift-expr
                        || rel-expr '<=' shift-expr
                        || rel-expr '>' shift-expr
                        || rel-expr '>=' shift-expr

shift-expr              := add-expr
                        || shift-expr '<<' add-expr
                        || shift-expr '>>' add-expr

add-expr                := mul-expr
                        || add-expr '+' mul-expr
                        || add-expr '-' mul-expr

mul-expr                := cast-expr
                        || mul-expr '*' cast-expr
                        || mul-expr '/' cast-expr
                        || mul-expr '%' cast-expr

cast-expr               := unary-expr
                        || '(' type-name ')' cast-expr
# Context-Sensitive Grammer here:
# unary-expr => '(' expr ')' => '(' identifer ')'
# '(' type-name ')' => '(' identifer ')'


unary-expr              := postfix-expr
                        || '++' unary-expr
                        || '--' unary-expr
                        || unary-op cast-expr
                        || 'sizeof' unary-expr
                        || 'sizeof' '(' type-name ')'

postfix-expr            := primary-expr
                        || postfix-expr '[' expr ']'
                        || postfix-expr '(' [argument-expr-list] ')'
                        || postfix-expr '.' identifier
                        || postfix-expr '->' identifier
                        || postfix-expr '++'
                        || postfix-expr '--'

primary-expr            := identifier
                        || constant
                        || string-literal
                        || '(' expr ')'

argument-expr-list      := assign-expr
                        || argument-expr-list ',' assign-expr

constant-expr           := cond-expr
# attr: const

=============== Statement ===============

stmt                    := labeled-stmt
                        || compound-stmt
                        || expression-stmt
                        || selection-stmt
                        || iteration-stmt
                        || jump-stmt

stmt-list               := stmt
                        || stmt-list stmt

                           # 注意这里，Label 是一个 identifier，不仅仅词法上符合，
                           # 语法行为也符合，比如有 function-wise scope。
                           # 而且，由于 Label: stmt 是一条语句，
                           # 所以 Label 无法在全局域出现，只能在某个函数体内。
labeled-stmt            := identifier ':' stmt
                        || 'case' constant-expr ':' stmt
                        || 'default' ':' stmt

compound-stmt           := '{' [declaration-list] [stmt-list] '}'

expression-stmt         := [expr] ';'

selection-stmt          := 'if' '(' expr ')' stmt
                        || 'if' '(' expr ')' stmt 'else' stmt           ＃ dangling 'else'
                        || 'switch' '(' expr ')' stmt

iteration-stmt          := 'while' '(' expr ')' stmt
                        || 'do' stmt 'while' '(' expr ')' ';'
                        || 'for' '(' [expr] ';' [expr] ';' [expr] ')' stmt

jump-stmt               := 'goto' identifier ';'
                        || 'continue' ';'
                        || 'break' ';'
                        || 'return' [expr] ';'

=============== Lexical ===============

identifer, constant, string-literal, ...

see C_Lexer.txt

------------------------------------------------------------------------
C 的 specifiers 有效组合

TC_VOID: void
TC_CHAR: char
TC_UCHAR: unsigned char
TC_SCHAR: signed char
TC_SHORT: (signed) short (int)
TC_USHORT: unsigned short (int)
TC_INT: (signed) (int)
TC_UINT: unsigned (int)
TC_LONG: (signed) long (int)
TC_ULONG: unsigned long (int)
TC_FLOAT: float
TC_DOUBLE: double
TC_LDOUBLE: long double
TC_STRUCT: struct {}
TC_UNION: union {}
TC_ENUM: enum {}
TC_TYPENAME: typedef

