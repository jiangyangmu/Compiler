C Syntax Environment & Label System

背景：
	在 C 里，绝大部分语句的 语义解释 和 代码生成，都要借助上下文。
		比如带自定义类型的语句，我们要根据上下文确定这个类型长什么样。
		又比如使用了前面定义的变量的语句，我们要根据上下文确定这个变量的类型和内存位置。
	由于语法给予的自由，一个语句块里，上下文是在不断变化的。
		可以加入新的变量。
		可以加入新的类型。
		可以替换一个 symbol 的含义，比如局部名字覆盖。
	作为编译器的制作者，我们必须追踪、管理这种变化。

---------------- 主要问题 ----------------
Q: 上下文 到底是什么？
	上下文实际上只做了一件事：告诉我们，看到的每个 symbol，在它那条语句里，代表什么。

Q: 上下文 包括什么？
	定义的类型，定义的变量。

-------------- 主要解决方案 ---------------
Q: 如何管理 上下文 的这种变化（加变量、加类型、替换符号）？

	如果没有替换，一个语句块中，对于一个符号的解释，只有两种可能：
		1. 符号未定义。
		2. 符号有唯一的定义。
	加上替换，则多了一种可能：
		3. 符号定义可能在中途被修改，因此可以在不同区域有不同定义

->	＃
	其实所有这些变化都记录在了语法树里。
	（所以语法树要和 SymbolTable, TypeTable 一起食用）
	＃

	看看 Symbol 的数据结构就明白了：
		Symbol = { Name, Type*, Location }
	其中的 Type 记录了这个 Symbol 到底是什么，比如
		struct A { int  i; } a;
		struct A { long l; } b;
	这两条语句中，结构 A 的定义被替换了，而这种区别体现在了 a, b 的 Type 指针上，
	它们实际上指着 TypeTable 中不同的类型。

->	＃
	替换其实只有两种情况，一个是替换的前后“都要记录”，一个是替换后的“临时覆盖”替换前的。
	（“临时覆盖” 的实现：SymbolTable 只需要像树一样彼此连接，就轻松实现。
			SymbolTable 每个语句块一个。和语法树并存）
	（“都要记录” 的实现：不仅要记录两个 struct A 的类型，还要记录哪个是最后定义的，
			可以用链表＋哈希表，旧的 A 放到链表，新的 A 可以通过哈希表["A"]定位到。
			TypeTable 每个语句块一个。和语法树并存）
	＃

	虽然语法上发生了替换，但：
		a. 类型定义替换 这种情况，我们仍然要 TypeTable 记录两种类型。
	对于另一种变量定义替换，通过 SymbolTable 树来解决，一个语句块最多一个 SymbolTable。
		b. 不像类型定义可以随意替换上面的同名类型，变量定义只能替换外部的同名定义。

---------------- 相关思考 ----------------
Q: 如何看待 int a = b + c; 这种语句？
	既利用了上下文，也修改了上下文。
	用了旧的上下文，生成新的上下文。
	这里引出了一个问题，我们是先计算 b + c 呢？还是先为 a 分配空间呢？
		这种情况，一般采用先分配，比较简单。



