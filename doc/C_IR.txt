
[CPU Storage]

general reigsters: stack-like allocation, vector-like r/w.
flag register
instruction register
argument type: imm, register

[CPU Instruction Set]

> statement
cmp,
jmp,
jl, jle,
jg, jge,
jb, jbe,
ja, jae,

> expression
mov,
or, xor, and, not, // bit-wise
shl, shr, // shift
add, sub,
mul, div, mod,
inc, dec, neg,
ref, deref,

// routine
param,
call,
ret,

[FPU Storage]

stack-like general registers
CPU's flag register

[FPU Instruction Set]

fld, fst, // load/store
fabs,
fchs, // change sign
fadd, fsub, fmul, fdiv,

--------------- Usage ---------------

# block 0
int a, b, c, s;
a = 1, b = 2, c = 3;
s = a + b + c;
if (s == 4)
{ # block 1
 b = (s++) + c;
 { # block 2
   int i, j, k;
   i = b;
   j = s;
   k = i + j;
   func(a, b, c);
 }
}
return 0

[ topological array model ]
? allocate space for temporaries (just reserve enough space)

 data layout of blocks (block 0, block 1, ...)
 | 0 | 1  | 2  | 3 | 4  | 5  | 6 |
 | a | b  | c  | s | t0 | t1 |
 |                 | t2 |
 |                 | i  | j  | k |

 ALLOC #7        # ALLOC 7
 # block 0
 MOV #1, 0       # MOV 1, a
 MOV #2, 1       # MOV 2, b
 MOV #3, 2       # MOV 3, c
 ADD 0, 1, 4     # ADD a, b, t0
 ADD 4, 2, 5     # ADD t0, c, t1
 MOV 5, 3        # MOV t1, s
 CMP 3, #4       # CMP s, 4
 JNE #??         # JNE ??  (backpack)
  # block 1
  MOV 3, 4       # MOV s, t2
  INC 3          # INC s
  ADD 4, 2, 1    # ADD t2, c, b
   # block 2
   MOV 1, 4      # MOV b, i
   MOV 3, 5      # MOV s, j
   ADD 4, 5, 6   # ADD i, j, k
   PARAM 0       # PARAM a
   PARAM 1       # PARAM b
   PARAM 2       # PARAM c
   CALL "func"
 RET 3           # RET s




NOTE:
variables (data with name, symbols in program): external data, argument data,
local data
temporaries (data without name, generated by compiler): temporary data
def expression = { assignment, inc, dec }

data location (in block):
     topological array model
jump (between blocks):
     * enter block
         allocate space
     * exit block
         free space

HOW:
pass 1: mark version of variables
 * how about jump statement?
   version is incorrect after jump.
pass 2: emit IR (keep tracking of data array)
 * how about jump statement?
   first, we know expressions are done when jump,
   so, no temporary when jump.
# block 0
int a, b, c, s;
a = 1, b = 2, c = 3;
s = a + b + c;
if (s == 4)
{ # block 1
 b = (s++) + c;
 { # block 2
   int i, j, k;
   i = b;
   j = s;
   k = i + j;
   func(a, b, c);
 }
}
return 0

[ topological array model ]
? allocate space for temporaries (just reserve enough space)

 data layout of blocks (block 0, block 1, ...)
 | 0 | 1  | 2  | 3 | 4  | 5  | 6 |
 | a | b  | c  | s | t0 | t1 |
 |                 | t2 |
 |                 | i  | j  | k |

 ALLOC #7        # ALLOC 7
 # block 0
 MOV #1, 0       # MOV 1, a
 MOV #2, 1       # MOV 2, b
 MOV #3, 2       # MOV 3, c
 ADD 0, 1, 4     # ADD a, b, t0
 ADD 4, 2, 5     # ADD t0, c, t1
 MOV 5, 3        # MOV t1, s
 CMP 3, #4       # CMP s, 4
 JNE #??         # JNE ??  (backpack)
  # block 1
  MOV 3, 4       # MOV s, t2
  INC 3          # INC s
  ADD 4, 2, 1    # ADD t2, c, b
   # block 2
   MOV 1, 4      # MOV b, i
   MOV 3, 5      # MOV s, j
   ADD 4, 5, 6   # ADD i, j, k
   PARAM 0       # PARAM a
   PARAM 1       # PARAM b
   PARAM 2       # PARAM c
   CALL "func"
 RET 3           # RET s




NOTE:
variables (data with name, symbols in program): external data, argument data,
local data
temporaries (data without name, generated by compiler): temporary data
def expression = { assignment, inc, dec }

data location (in block):
     topological array model
jump (between blocks):
     * enter block
         allocate space
     * exit block
         free space

HOW:
pass 1: mark version of variables
 * how about jump statement?
   version is incorrect after jump.
pass 2: emit IR (keep tracking of data array)
 * how about jump statement?
   first, we know expressions are done when jump,
   so, no temporary when jump.
# block 0
int a, b, c, s;
a = 1, b = 2, c = 3;
s = a + b + c;
if (s == 4)
{ # block 1
 b = (s++) + c;
 { # block 2
   int i, j, k;
   i = b;
   j = s;
   k = i + j;
   func(a, b, c);
 }
}
return 0

[ topological array model ]
? allocate space for temporaries (just reserve enough space)

 data layout of blocks (block 0, block 1, ...)
 | 0 | 1  | 2  | 3 | 4  | 5  | 6 |
 | a | b  | c  | s | t0 | t1 |
 |                 | t2 |
 |                 | i  | j  | k |

 ALLOC #7        # ALLOC 7
 # block 0
 MOV #1, 0       # MOV 1, a
 MOV #2, 1       # MOV 2, b
 MOV #3, 2       # MOV 3, c
 ADD 0, 1, 4     # ADD a, b, t0
 ADD 4, 2, 5     # ADD t0, c, t1
 MOV 5, 3        # MOV t1, s
 CMP 3, #4       # CMP s, 4
 JNE #??         # JNE ??  (backpack)
  # block 1
  MOV 3, 4       # MOV s, t2
  INC 3          # INC s
  ADD 4, 2, 1    # ADD t2, c, b
   # block 2
   MOV 1, 4      # MOV b, i
   MOV 3, 5      # MOV s, j
   ADD 4, 5, 6   # ADD i, j, k
   PARAM 0       # PARAM a
   PARAM 1       # PARAM b
   PARAM 2       # PARAM c
   CALL "func"
 RET 3           # RET s




NOTE:
variables (data with name, symbols in program): external data, argument data,
local data
temporaries (data without name, generated by compiler): temporary data
def expression = { assignment, inc, dec }

data location (in block):
     topological array model
jump (between blocks):
     * enter block
         allocate space
     * exit block
         free space

HOW:
pass 1: mark version of variables
 * how about jump statement?
   version is incorrect after jump.
pass 2: emit IR (keep tracking of data array)
 * how about jump statement?
   first, we know expressions are done when jump,
   so, no temporary when jump.
# block 0
int a, b, c, s;
a = 1, b = 2, c = 3;
s = a + b + c;
if (s == 4)
{ # block 1
 b = (s++) + c;
 { # block 2
   int i, j, k;
   i = b;
   j = s;
   k = i + j;
   func(a, b, c);
 }
}
return 0

[ topological array model ]
? allocate space for temporaries (just reserve enough space)

 data layout of blocks (block 0, block 1, ...)
 | 0 | 1  | 2  | 3 | 4  | 5  | 6 |
 | a | b  | c  | s | t0 | t1 |
 |                 | t2 |
 |                 | i  | j  | k |

 ALLOC #7        # ALLOC 7
 # block 0
 MOV #1, 0       # MOV 1, a
 MOV #2, 1       # MOV 2, b
 MOV #3, 2       # MOV 3, c
 ADD 0, 1, 4     # ADD a, b, t0
 ADD 4, 2, 5     # ADD t0, c, t1
 MOV 5, 3        # MOV t1, s
 CMP 3, #4       # CMP s, 4
 JNE #??         # JNE ??  (backpack)
  # block 1
  MOV 3, 4       # MOV s, t2
  INC 3          # INC s
  ADD 4, 2, 1    # ADD t2, c, b
   # block 2
   MOV 1, 4      # MOV b, i
   MOV 3, 5      # MOV s, j
   ADD 4, 5, 6   # ADD i, j, k
   PARAM 0       # PARAM a
   PARAM 1       # PARAM b
   PARAM 2       # PARAM c
   CALL "func"
 RET 3           # RET s




NOTE:
variables (data with name, symbols in program): external data, argument data,
local data
temporaries (data without name, generated by compiler): temporary data
def expression = { assignment, inc, dec }

data location (in block):
     topological array model
jump (between blocks):
     * enter block
         allocate space
     * exit block
         free space

HOW:
pass 1: mark version of variables
 * how about jump statement?
   version is incorrect after jump.
pass 2: emit IR (keep tracking of data array)
 * how about jump statement?
   first, we know expressions are done when jump,
   so, no temporary when jump.
