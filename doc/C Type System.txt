TYPE SYSTEM

=============================================
            符号系统是什么？
            和名字有关的一切
=============================================

> 名字
    对象的名称
    类型的名称（struct TAG, typedef NAME）

> 名字空间（namespace），有效区间（scope）
    主空间划分（root namespace）：根据出现位置
        A -> label name (语句开头)
        B -> struct/union member (struct/union/enum 定义体内)
        C -> struct/union/enum tag (struct/union/enum 后面)
        D -> other(object, enum-constant, typedef-name) (除了前三个的地方)
    子空间划分（namespace)：根据语法嵌套
        A -> 不再分
        B,C,D -> 树形细分
    有效区间划分（scope）
        A -> 享有整个空间
        B,C,D -> 享有整个当前子空间，会被子子空间同名称对象屏蔽

    * '语句块' 是一种能创建 树形namespace 的东西。
    * label name 是唯一真正能跨越 树形namespace 的东西。
    * 冲突：首先，在不同 namespace 的东西不会冲突。其次，同一 namespace 下，
      也是有不同的空间布局的，scope 描述的就是在哪个空间哪个区段，只有在同一
      空间，而且区段有交叠的时候，才会发生冲突。
      所以，要发生冲突，一要在同一 namespace，二要在同一空间，三要区段有交叠。


=============================================
            对象系统是什么？
            和内存有关的一切
=============================================

> 属性
    大小

> 状态
    数值对象的值
    聚合对象的值
    函数对象的参数、值

=============================================
            类型系统是什么？
            和行为有关的一切
=============================================

> 特征
    类型描述（typedef 定义、对象使用）
    匹配（相等？兼容？）

> 行为
    是否 incomplete
    是否 lvalue
    可进行的操作

. 类型类别
    数值
    指针
    数组
    结构体
    函数

---------------------------------------------
                问题集锦
---------------------------------------------

Q: 硬件对类型转换的支持？ [ok]
Q: 作用域：如何管理全局变量？
    访问管理 和 局部变量是一样的。
    内存位置则固定为 全局区的一个 slot。
Q: enum 没有 forward-declaration，如何处理？
Q: 左值（lvalue）是什么？ [ok]
lvalue is an expression referring to an object.
Q: "判断一个对象是否可以执行某个操作" 的机制？ [ok]
Q: 如何管理函数的声明与定义？ [ok]

---------------------------------------------
Q: 如何定义一个类型？如何定义一个类型的对象？

类型定义系统

type => identifier OR '(declarator)' is ( [array of] ||  [function returns] ) [pointer of] specifier
（先里面，再右结合，再左结合。）


类型定义语法中的优先级：
    1. right > left
    2. near > far
    3. position: specifier (pointer) ID (array | function)
    => array = function > pointer > specifier

pointer > specifier     := T *a         -> (T (*a) )

function > pointer      := T *f(void)   -> (T (* (f(void)) ))
function > specifier    := T f(int)     -> (T (f(void)) )

array > pointer         := T *a[3]      -> (T (* (a[3]) ))
array > specifier       := T a[3]       -> (T (a[3]) )

---------------------------------------------
[~~~~~running~~~~~]
Q: "类型转换" 和 "类型提升" 的机制？

见 C_Conversion.txt

---------------------------------------------
Q: 类型名的，变量名的，函数名的，符号空间冲突？
    类型名：struct/union tag, enum tag
        -> 相互之间无障碍覆盖
    变量名：id, struct/union-member-id, enum-member

关于 scope, namespace, linkage

[SCOPE]
identifier can be...
    -> object(arithmatic, pointer, array, func)
    -> struct/union/enum tag
    -> struct/union-member
    -> enum-constant
    -> function-param
    -> typedef name
    -> label name
    -> (or) macro name, macro parameter

scope starts
    after identifier appear
        tag, enum-constant
    after declarator finish
        OTHERS

scope range
    function - in whole function
        label name
    file - until EOF
        global declarations
    block - until '}'
        func-definition-params, local declarations
    function-prototype - until ';' (意思是，函数声明里，给参数加名字没卵用)
        func-declaration-params

[NAMESPACE]
in the same layer, there are 4 separate namespaces:
    -> label name
    -> tag
    -> struct/union member
    -> other(object, enum-constant)

---------------------------------------------
Q: 类型系统 和 表达式 的交互？

某个表达式的类型：自己知道 or 合成
类型约束：类型是否支持此表达式

TODO:
    1. 类型约束 [ok]
    2. 表达式结合性 [ok]
    3. 表达式类型合成
    4. 多余环境清理，函数环境清理

---------------------------------------------
Q：类型系统字符串化！

work:
    类型精确描述

limits:
    Max Object Size(e.g. array, struct) = size_t

功效：
    O(1) 类型匹配
    O(1) 类型兼容度检测

type => identifier OR '(declarator)' is ( [array of] ||  [function returns] ) [pointer of] specifier

specifiers:
    storage-specifier   := typedef || extern || static || auto || register
        [ignore for now]
    type-qualifier      := const || volatile
        const -> 'C'
    type-specifier      := void || char || short || int || long || float || double || signed || unsigned
                        || struct-or-union-specifier
                        || enum-specifier
                        || typedef-name
        void    -> 'v'
        char    -> 'c'  || 'i1' || 'u1'
        short   -> 'i2' || 'u2'
        int     -> 'i4' || 'u4'
        long    -> 'i8' || 'u8'
        float   -> 'f4'
        double  -> 'f8'
        struct  -> 'S' <name> ('_' <mem>)* '$'
        union   -> 'U' <name> ('_' <mem>)* '$'
        enum    -> 'E' <name> '$'
declarator:
    ( pointer )? ( idenifier || '(' declarator ')' ) ( ('[' ( constant-expr )? ']')* || ('(' ( param-list )? ')')? )
    pointer             := ( '*' [type-qualifier-list] )+
        pointer -> ( 'P' ['C'] )+
        array   -> 'A' ('_' <dim>)+ '$'
        func    -> 'F' ('_' <param>)* '$'








