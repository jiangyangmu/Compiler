C Grammar

================ Translation Unit ===============

translation-unit		:=
						{ new_env();
						  scope_begin(IN_FILE); }
		(function-definition || declaration)+
						{ scope_end(); }

function-definition	:=
						{ specifier_qualifier_begin();
						  storage_begin(); }
		declaration-specifiers
		declarator
						{ // type must be function
						  type_set_specifier_qualifier(specifier_qualifier_get());
						  specifier_qualifier_end();

						  new_symbol();
						  symbol_set_id(id_pop());
						  symbol_set_symbol_type(
						  	storage_get() == typedef
						  	? ALIAS
						  	: ID
						  );
						  symbol_set_storage_type(
						  	compute_storage_type(
						  	IN_FILE,
						  	storage_get(),
						  	FUNC_DEFINITION,
						  	env_find_in_file_scope(symbol_get_id(), symbol_get_symbol_type())
						  	)
						  );
						  symbol_set_object_type(type_top());
						  if (storage_get() != 'static')
						  	symbol_set_export();
						  storage_end();

						  env_add_symbol(symbol_pop());
						  env_push(function_get_env());
						  type_pop();
						  scope_begin(IN_COMPOUND_STATEMENT); }
		compound-statment
						{ scope_end();
						  env_pop();
						  function_set_body(...); }

declaration		:=
						{ specifier_qualifier_begin();
						  storage_begin(); }
		declaration-specifiers
		[ declarator-initializer (',' declarator-initializer)* ]
		';'
						{ specifier_qualifier_end();
						  storage_end(); }

declarator-initializer	:=
		declarator
						{ type_set_specifier_qualifier(specifier_qualifier_get());

						  new_symbol();
						  symbol_set_id(id_pop());
						  symbol_set_symbol_type(
						  	storage_get() == typedef
						  	? ALIAS
						  	: ID
						  );
						  symbol_set_storage_type(
						  	compute_storage_type(
						  	scope_get(),
						  	storage_get(),
						  	type_top().isFunction()
						  		? FUNC_DECLARATION
						  		: OBJECT,
						  	env_find_in_file_scope(symbol_get_id(), symbol_get_symbol_type())
						  	)
						  );
						  symbol_set_object_type(type_pop());
						  if (storage_get() != 'static')
						  	symbol_set_export();
						  storage_end();

						  env_add_sym(symbol_pop()); }
		('=' initializer)?

================== Declarator ==================

declarator		:=
						{ new_type(); }
		[
			pointer-list			{ type_merge(); }
		]
		(
			identifier			{ new_id(identifier); new_type(); }
		||	'(' declarator ')'
		)
		(
						{ new_array(); }
			'['
			[
				constant-expr		{ array_set_size(int); }
			]
			']'
						{ type_merge(); }
		||
						{ new_function(); }
			'(' [parameter-list] ')'
						{ type_merge(); }
		)*
						{ type_merge(); // merge pointer }

abstract-declarator	:=
						{ new_type(); }
		[
			pointer-list			{ type_merge(); }
		]
						{ new_type(); }
		[
			'(' abstract-declarator ')'		{ type_merge(); }
		]
		(
						{ new_array(); }
			'['
			[
				constant-expr		{ array_set_size(int); }
			]
			']'
						{ type_merge(); }
		||
						{ new_function(); }
			'(' [parameter-list] ')'
						{ type_merge(); }
		)*
						{ type_merge(); // merge pointer }

parameter-list		:=
						{ scope_begin(IN_PARAMETER_LIST); }
		parameter-declaration
		(
			',' parameter-declaration
		)*
		(
			',' '...'			{ function_set_varlist(); }
		)?
						{ scope_end(); }

parameter-declaration	:=
						{ specifier_qualifier_begin();
						  storage_begin(); }
		declaration-specifiers
		(
			declarator
						{ type_set_specifier_qualifier(specifier_qualifier_get());
						  specifier_qualifier_end();
						  // expect auto/register storage
						  storage_end();
						  function_add_parameter(id_pop(), type_pop()); }
		||
			[abstract-declarator]		{// todo}
		)

pointer-list		:=
		pointer
		(
			pointer			{ type_merge(); }
		)*

pointer		:=
		'*'				{ qualifier_begin(); }
		(type-qualifier)+
						{ new_pointer();
						  pointer_set_qualifier(qualifier_get());
						  qualifier_end();
						}

// todo
type-name		:=
		(
		type-specifier
		|| type-qualifier
		)+
		[abstract-declarator]

================== Specifiers ==================

declaration-specifiers  	:=
		(storage-class-specifier | type-specifier | type-qualifier)+

storage-class-specifier	:=
		   'typedef'				{ storage_add(token); }
		|| 'extern'				{ storage_add(token); }
		|| 'static'				{ storage_add(token); }
		|| 'auto'				{ storage_add(token); }
		|| 'register'				{ storage_add(token); }

type-qualifier		:=
		   'const'				{ qualifier_add(token); }
		|| 'volatile'				{ qualifier_add(token); }

type-specifier		:=
		   'void' || 'char' || 'short' || 'int' || 'long' || 'float' || 'double' || 'signed' || 'unsigned'
						{ specifier_add(token); }
		|| struct-or-union-specifier			{ specifier_add(struct, type); }
		|| enum-specifier			{ specifier_add(enum, type); }
		|| typedef-name			{ specifier_add(typedef, type); }


struct-or-union-specifier
		:=
		('struct' || 'union')			{ new_struct(); }
		[
		identifier				{ struct_set_name(identifier); }
		]
		[
			'{' (struct-declaration)+ '}'		{ struct_complete(); }
		]
						{ new_symbol();
						  symbol_set_id(struct_get_name());
						  symbol_set_symbol_type(tag);
						  symbol_set_storage_type(none);
						  symbol_set_object_type(type_top());
						  env_add_symbol(symbol_pop());
						}

struct-declaration	:=
						{ specifier_qualifier_begin(); }
		(
		type-specifier
		||
		type-qualifier
		)+
		struct-declarator
						{ type_set_specifier_qualifier(specifier_qualifier_get());
						  struct_add_member(id_pop(), type_pop()); }
		(
			','
			struct-declarator		{ ...same... }
		)*
		';'				{ specifier_qualifier_end(); }

struct-declarator	:=
		[
			declarator
		]
		[
			':' constant-expression		{ // TODO: bit-field }
		]

enum-specifier		:=
		'enum'				{ new_enum(); }
		[
		identifier				{ enum_set_name(identifier); }
		]
		[
			'{'
			enumeration-constant		{ enum_add_const(enum-constant);
						  new_symbol();
						  symbol_set_id(enum-constant);
						  symbol_set_symbol_type(id);
						  symbol_set_storage_type(none);
						  symbol_set_object_type(type_top());
						  env_add_symbol(symbol_pop());
						}
			[
			'='
			constant-expr			{ enum_set_const_value(...); } // TODO: const engine
			]
			(
				','
				enumeration-constant	{ ...same... }
				[
				'='
				constant-expr	{ ...same... }
				]
			)*
			'}'			{ enum_complete(); }
		]
						{ new_symbol();
						  symbol_set_id(enum_get_name());
						  symbol_set_symbol_type(tag);
						  symbol_set_storage_type(none);
						  symbol_set_object_type(type_top());
						  env_add_symbol(symbol_pop());
						}

typedef-name		:=
		identifier				{ type_push(env_find(identifier, type_alias)); }

================== Initialize ==================

initializer		:=
		assign-expr
		|| '{' initializer-list [','] '}'

initializer-list		:= initializer
		|| initializer-list ',' initializer

=================== Expression ===============

expr		:=
		comma-expr

comma-expr		:=
		assign-expr
		(
			',' assign-expr			{}
		)*

assign-expr		:=
		cond-expr
		[
			assign-op
			assign-expr			{ expr_assign(op_pop(), expr_pop(), expr_pop()); }
		]

cond-expr		:=
		OR-expr
		[
			'?' expr
			':' cond-expr
		]

OR-expr		:=
		AND-expr
		(
			'||' AND-expr
		)*

AND-expr		:=
		bit-OR-expr
		(
			'&&' bit-OR-expr
		)*

bit-OR-expr		:=
		bit-XOR-expr
		(
			'|' bit-XOR-expr
		)*

bit-XOR-expr		:=
		bit-AND-expr
		(
			'^' bit-AND-expr
		)*

bit-AND-expr		:=
		eq-expr
		(
			'&' eq-expr
		)*

eq-expr		:=
		rel-expr
		(
			('==' || '!=')
			rel-expr
		)*

rel-expr		:=
		shift-expr
		(
			('<' || '<=' || '>' || '>=')
			shift-expr
		)*

shift-expr		:=
		add-expr
		(
			('<<' || '>>')
			add-expr
		)*

add-expr		:=
		mul-expr
		(
			('+' || '-')
			mul-expr
		)*

mul-expr		:=
		cast-expr
		(
			('*' | '/' | '%')
			cast-expr
		)*

cast-expr		:=
		(
			'('
			type-name
			')'
		)*
		unary-expr

unary-expr		:=
			postfix-expr
		||
			('++' || '--')
			unary-expr			// TODO: expand self-loop?
		||
			unary-op
			cast-expr
		||
			'sizeof'
			(
				unary-expr
			||
				'(' type-name ')'
			)

postfix-expr		:=
		primary-expr
		(
			'[' expr ']'
		||
			'(' [argument-expr-list] ')'
		||
			'.' identifier
		||
			'->' identifier
		||
			'++'
		||
			'--'
		)*

primary-expr		:=
			identifier
		||
			constant
		||
			string-literal
		||
			'('
			expr
			')'

argument-expr-list	:=
		assign-expr
		(
			',' assign-expr
		)*

constant-expr		:=
		cond-expr

=============== Statement ===============

stmt		:=
		labeled-stmt
		|| compound-stmt
		|| expression-stmt
		|| selection-stmt
		|| iteration-stmt
		|| jump-stmt

labeled-stmt		:=
		identifier ':' stmt			{ new_label_stmt(); }
		|| 'case' constant-expr ':' stmt			{ new_case_stmt(expr_pop(), stmt_pop()); }
		|| 'default' ':' stmt			{ new_default_stmt(); }

compound-stmt	:=
						{ new_compound_stmt();
						  new_env(); }
		'{'
			(declaration)*
			(
			stmt			{ compound_stmt_add(stmt_pop()); }
			)*
		'}'
						{ compound_stmt_set_env(env_pop()); }

expression-stmt	:=
						{ new_expr_stmt(); }
		[
			expr			{ expr_stmt_set_expr(expr_pop()); }
		]
		';'

selection-stmt		:=
						{ new_if_stmt(); }
			'if' '('
			expr			{ if_stmt_set_expr(expr_pop()); }
			')'
			stmt			{ if_stmt_set_if_block(stmt_pop()); }
			[
				'else'
				stmt		{ if_stmt_set_else_block(stmt_pop()); }
			]
		||
						{ new_switch_stmt(); }
			'switch' '('
			expr			{ switch_set_expr(expr_pop()); }
			')'
			stmt			{ switch_set_stmt(stmt_pop()); }

iteration-stmt		:=
						{ new_while_stmt(); }
			'while' '('
				expr		{ while_set_expr(expr_pop()); }
			')'
				stmt		{ while_set_stmt(stmt_pop()); }
		||
						{ new_do_while_stmt(); }
			'do'
				stmt		{ do_while_set_stmt(expr_pop()); }
			'while' '('
				expr		{ do_while_set_expr(stmt_pop()); }
			')' ';'
		||
						{ new_for_stmt(); }
			'for' '('
			[
				expr		{ for_stmt_set_init_expr(expr_pop()); }
			]
			';'
			[
				expr		{ for_stmt_set_cond_expr(expr_pop()); }
			]
			';'
			[
				expr		{ for_stmt_set_tail_expr(expr_pop()); }
			]
			')'
				stmt		{ for_stmt_set_stmt(stmt_pop()); }

jump-stmt		:=
			'goto' identifier ';'		{ new_goto_stmt();
						  goto_stmt_set_label(token); }
		||
			'continue' ';'			{ new_continue_stmt(); }
		||
			'break' ';'			{ new_break_stmt(); }
		||
			'return'			{ new_return_stmt(); }
			[
				expr		{ return_stmt_set_expr(expr_pop()); }
			]
			';'

=============== Lexical ===============

unary-op                := & * + - ~ !

identifer, constant, string-literal, ...

see C_Lexer.txt

